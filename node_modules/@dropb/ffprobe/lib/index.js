"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ffprobe: () => ffprobe,
  ffprobeSync: () => ffprobeSync
});
module.exports = __toCommonJS(src_exports);

// src/ffprobe.ts
var import_child_process = require("child_process");
var import_stream = require("stream");
var import_util = require("util");
var args = [
  "-v",
  "quiet",
  "-print_format",
  "json",
  "-show_format",
  "-show_streams",
  "-show_error",
  "-i"
];
ffprobe.path = "ffprobe";
var parseStdout = (stdout) => {
  try {
    const value = JSON.parse(stdout);
    if ("format" in value) {
      return { value };
    }
    if ("error" in value) {
      return {
        error: Object.assign(new Error(value.error.string), {
          name: "FfprobeError",
          code: value.error.code
        })
      };
    }
  } catch {
  }
  return {
    error: Object.assign(new Error("Erroneous response from ffprobe"), { stdout })
  };
};
var ffprobePromise = (input) => {
  return new Promise((resolve, reject) => {
    const inputIsStream = isStream(input);
    const source = inputIsStream ? "pipe:0" : input;
    const { stdin } = (0, import_child_process.execFile)(
      process.env.FFPROBE_PATH || ffprobe.path,
      [...args, source],
      (ex, stdout, stderr) => {
        if (!stdout)
          return reject(ex || new Error("No output from ffprobe"));
        const { error, value } = parseStdout(stdout);
        return error ? reject(error) : resolve(value);
      }
    );
    if (inputIsStream) {
      if (!stdin)
        return reject(new Error("Error opening stdin"));
      input.pipe(stdin);
    }
  });
};
function ffprobe(input, cb) {
  if (cb) {
    ffprobePromise(input).then((data) => cb(null, data)).catch(cb);
  } else {
    return ffprobePromise(input);
  }
}
function isStream(input) {
  return input instanceof import_stream.Stream && typeof input._read === "function";
}
function ffprobeSyncDeprecated(input) {
  const { error, stdout } = (0, import_child_process.spawnSync)(process.env.FFPROBE_PATH || ffprobe.path, [...args, input]);
  if (error) {
    throw error;
  }
  const data = parseStdout(stdout.toString());
  if (data.error) {
    throw data.error;
  }
  return data.value;
}
var ffprobeSync = (0, import_util.deprecate)(ffprobeSyncDeprecated, "ffprobeSync() is deprecated.");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ffprobe,
  ffprobeSync
});
